const std = @import("std");
const gpa = std.heap.c_allocator;

const inquirer = @import("inquirer");
const detectlicense = @import("detect-license");
const u = @import("./../util/index.zig");

//
//

const s_in_y = std.time.s_per_week * 52;

pub fn execute(args: [][]u8) !void {
    _ = args;

    std.debug.print("This utility will walk you through creating a zig.mod file.\n", .{});
    std.debug.print("That will give a good launching off point to get your next project started.\n", .{});
    std.debug.print("Use `zigmod aq add <pkg>` to add a dependency from https://aquila.red/\n", .{});
    std.debug.print("Press ^C at any time to quit.\n", .{});
    std.debug.print("\n", .{});

    const stdout = std.io.getStdOut().writer();
    const stdin = std.io.getStdIn().reader();
    const cwd = std.fs.cwd();

    const id = try inquirer.answer(stdout, "ID (this gets autogenerated):", []const u8, "{s}", try u.random_string(48));

    const ptype = try inquirer.forEnum(stdout, stdin, "Are you making an application or a library?", gpa, enum { exe, lib }, null);

    const name = try inquirer.forString(stdout, stdin, "package name:", gpa, u.detect_pkgname(u.try_index([]const u8, args, 0, ""), "") catch |err| switch (err) {
        error.NoBuildZig => {
            u.assert(false, "init requires a build.zig file", .{});
            unreachable;
        },
        else => return err,
    });

    const entry = if (ptype == .lib) try inquirer.forString(stdout, stdin, "package entry point:", gpa, u.detct_mainfile(u.try_index([]const u8, args, 1, ""), null, name) catch |err| switch (err) {
        error.CantFindMain => null,
        else => return err,
    }) else null;

    const license = try inquirer.forString(stdout, stdin, "license:", gpa, try detectlicense.detectInDir(gpa, cwd));

    const description = try inquirer.forString(stdout, stdin, "description:", gpa, null);

    std.debug.print("\n", .{});
    std.debug.print("About to write local zig.mod:\n", .{});

    std.debug.print("\n", .{});
    switch (ptype) {
        .exe => try writeExeManifest(stdout, id, name, license, description),
        .lib => try writeLibManifest(stdout, id, name, entry.?, license, description),
    }

    std.debug.print("\n", .{});
    switch (try inquirer.forConfirm(stdout, stdin, "Is this okay?", gpa)) {
        false => {
            std.debug.print("okay. quitting...", .{});
            return;
        },
        true => {
            const file = try cwd.createFile("zig.mod", .{});
            defer file.close();
            const w = file.writer();
            switch (ptype) {
                .exe => try writeExeManifest(w, id, name, license, description),
                .lib => try writeLibManifest(w, id, name, entry.?, license, description),
            }
            std.debug.print("\n", .{});
            u.print("Successfully initialized new package {s}!\n", .{name});
        },
    }

    // ask about .gitignore
    if (try u.does_folder_exist(".git")) {
        const do = try inquirer.forConfirm(stdout, stdin, "It appears you're using git. Do you want init to add Zigmod to your .gitignore?", gpa);
        if (do) {
            const exists = try u.does_file_exist(".gitignore", null);
            const file = try (if (exists) cwd.openFile(".gitignore", .{ .read = true, .write = true }) else cwd.createFile(".gitignore", .{}));
            defer file.close();
            try file.seekTo(try file.getEndPos());
            const w = file.writer();

            if (!exists) try w.writeAll("zig-*\n");
            try w.writeAll(".zigmod\n");
            try w.writeAll("deps.zig\n");
        }
    }

    // ask about LICENSE
    if (!(try u.does_file_exist("LICENSE", null))) {
        if (detectlicense.licenses.find(license)) |text| {
            if (try inquirer.forConfirm(stdout, stdin, "It appears you don't have a LICENSE file defined, would you like init to add it for you?", gpa)) {
                var realtext = text;
                realtext = try std.mem.replaceOwned(u8, gpa, realtext, "<year>", try inquirer.answer(
                    stdout,
                    "year:",
                    []const u8,
                    "{s}",
                    try std.fmt.allocPrint(gpa, "{d}", .{1970 + @divFloor(std.time.timestamp(), s_in_y)}),
                ));
                realtext = try std.mem.replaceOwned(u8, gpa, realtext, "<copyright holders>", try inquirer.forString(
                    stdout,
                    stdin,
                    "copyright holder's name:",
                    gpa,
                    guessCopyrightName(),
                ));

                const file = try cwd.createFile("LICENSE", .{});
                defer file.close();
                const w = file.writer();
                try w.writeAll(realtext);
            }
        }
    }
}

pub fn writeExeManifest(w: std.fs.File.Writer, id: []const u8, name: []const u8, license: ?[]const u8, description: ?[]const u8) !void {
    try w.print("id: {s}\n", .{id});
    try w.print("name: {s}\n", .{name});
    if (license) |_| try w.print("license: {s}\n", .{license.?});
    if (description) |_| try w.print("description: {s}\n", .{description.?});
    try w.print("dev_dependencies:\n", .{});
}

pub fn writeLibManifest(w: std.fs.File.Writer, id: []const u8, name: []const u8, entry: []const u8, license: []const u8, description: []const u8) !void {
    try w.print("id: {s}\n", .{id});
    try w.print("name: {s}\n", .{name});
    try w.print("main: {s}\n", .{entry});
    try w.print("license: {s}\n", .{license});
    try w.print("description: {s}\n", .{description});
    try w.print("dependencies:\n", .{});
}

fn guessCopyrightName() ?[]const u8 {
    const result = u.run_cmd_raw(null, &.{ "git", "config", "--get", "user.name" }) catch return null;
    defer gpa.free(result.stdout);
    defer gpa.free(result.stderr);
    return if (result.term.Exited == 0) gpa.dupe(u8, std.mem.trim(u8, result.stdout, " \n\t")) catch null else null;
}
